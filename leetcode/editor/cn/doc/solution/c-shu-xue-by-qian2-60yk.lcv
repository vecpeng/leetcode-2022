### 解题思路

这道题目长得非常像约瑟夫环，但不是约瑟夫环。

中文题目中没有给出数据范围，这里我们巧妙地将题目切换为英文（翻译经常会出现漏翻，错翻，格式不对的问题），
![image.png](https://pic.leetcode-cn.com/1641054172-LIDVHF-image.png)
然后就可以看到数据范围是 $1 <= n <= 10^9$
![image.png](https://pic.leetcode-cn.com/1641054190-QEXrnC-image.png)
因此根据数据规模，可以推算出算法的时间复杂度应该小于$O(n)$，到达$O(\log n)$这个级别。

因此直接用一个数组表示所有数字，再依次删除模拟整个过程的方法是不行的，我们需要考虑使用某种精妙的方法来表示每一回合的数。

> n = 9
> arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
> arr = [2, 4, 6, 8]
> arr = [2, 6]
> arr = [6]

通过观察用例，我们可以得到以下规律：
1. 经历的回合数应该是 $\lfloor \log_2n \rfloor + 1$
2. **arr数组永远是一个等差数列**
3. arr数组的数目，每次减少一半（向下取整）
4. 公差每次翻倍

其中，第二条规律是最令人兴奋的，因为它可以帮助我们使用一些简单的参数就可以表示所有剩余的数字。通过回忆高中数学的知识，我们知道一个等差数列可以由$a_0（首项）, d（公差）, n（数列元素个数）$三个参数来定义。

综合以上规律，我们知道每次删除后，以上三个参数每次应该这样变化：
- $d → 2d$
- $n → 2n$
- $a_0 → a_0\ 或\ a_0+d$

大体上来说这道题目就是这样，其它细节可以看代码。

**如何决定$a_0$的变化**

答：当删除数字时，存在以下四种情况：
1. 从左向右删除，总共有奇数个数字（第一位要删掉，最后一位要删掉）
2. 从左向右删除，总共有偶数个数字（第一位要删掉，最后一位不用删掉）
3. 从右向左删除，总共有奇数个数字（第一位要删掉，最后一位要删掉）
4. 从右向左删除，总共有偶数个数字（第一位不用删掉，最后一位要删掉）

可以发现，若$a_0 → a_0$，则必然为情况4；其余情况都为$a_0 → a_0+d$

### 代码

![image.png](https://pic.leetcode-cn.com/1641054206-vPcjRa-image.png)

* cpp

```cpp
class Solution {
public:
    int lastRemaining(int n) {
        int num_amount = n;
        int loop_cnt = 0;
        int a0 = 1, d = 1;
        while(num_amount != 1) {
            // 奇数个数字
            if(num_amount % 2 == 1) {
                a0 = a0 + d;
            }
            // 偶数个数字
            else if(num_amount % 2 == 0) {
                bool left_to_right = (loop_cnt % 2 == 0);
                if(left_to_right) {
                    a0 = a0 + d;
                }
                else
                    a0 = a0;
            }
            loop_cnt++;
            d *= 2;
            num_amount /= 2;
        }
        return a0;
    }
};
```

